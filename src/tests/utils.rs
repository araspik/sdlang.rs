//! PropTest utilities for SDLang.
//!
//! Provides some testing stuffs for types not directly associated with SDLang
//! types (e.g the used `Date` type).

use crate::Result;
use crate::{
    grammar,
    grammar::{ParseTree, Rule},
};

use std::fmt::Debug;

/// The test type.
///
/// This is the test type generated by proptest value generation functions.
#[derive(Debug, Clone)]
pub struct Test<T: Clone> {
    /// The text to parse.
    pub text: String,
    /// The expected result.
    pub result: T,
}

impl<T: Clone> Test<T> {
    /// Creates a new test.
    pub fn new(text: String, result: T) -> Self {
        Self { text, result }
    }

    /// Maps the result.
    pub fn map_res<R: Clone, F: FnOnce(T) -> R>(self, f: F) -> Test<R> {
        Test {
            text: self.text,
            result: f(self.result),
        }
    }

    /// Maps the text.
    pub fn map_text<F: FnOnce(String) -> String>(self, f: F) -> Self {
        Self {
            text: f(self.text),
            result: self.result,
        }
    }
}

/// Holds all aspects of a single rule to test.
///
/// Useful for testing multiple tests simultaneously.
pub struct RuleSet<T>
where
    T: Debug + PartialEq + Clone,
{
    /// The rule type for parsing.
    rule: Rule,
    /// The parse tree parsing function.
    func: fn(ParseTree) -> Result<T>,
}

impl<T> RuleSet<T>
where
    T: Debug + PartialEq + Clone,
{
    /// Creates a new rule set.
    pub fn new(rule: Rule, func: fn(ParseTree) -> Result<T>) -> Self {
        Self { rule, func }
    }

    /// Tests with the given test.
    ///
    /// Panics on failure.
    pub fn test(&self, test: Test<T>) {
        match grammar::parse(self.rule, &test.text).and_then(self.func) { 
            Ok(res)  => assert_eq!(res, test.result),
            Err(err) => panic!("ERROR: {}", err),
        };
    }
}
